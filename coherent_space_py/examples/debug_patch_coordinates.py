"""
Utility script to inspect the lattice (q, r) steps and physical positions
generated by InfiniteCoherentGraph for a small patch.

This prints, per netting and per application role:
  * how many nodes were generated
  * the min/max lattice steps (q, r) covered
  * a few sample rows containing (id, q, r, app_type, vector_direction, position)

Usage:
    PYTHONPATH=. python coherent_space_py/examples/debug_patch_coordinates.py
    PYTHONPATH=. python coherent_space_py/examples/debug_patch_coordinates.py --range 3
"""
from __future__ import annotations

import argparse
from collections import defaultdict
from typing import Dict, List, Tuple

from coherent_space_py.model.infinite_graph import InfiniteCoherentGraph
from coherent_space_py.model.enums import (
    InformationalStreamNetting,
    StreamApplicationType,
)


def summarize(nodes) -> None:
    grouped: Dict[Tuple[InformationalStreamNetting, StreamApplicationType], List] = defaultdict(list)
    for node in nodes:
        grouped[(node.netting, node.stream_application_type)].append(node)

    print("=== Patch summary ===")
    for (netting, app_type), bucket in sorted(grouped.items(), key=lambda x: (x[0][0].value, x[0][1].value)):
        qs = [n.lattice_steps[0] for n in bucket]
        rs = [n.lattice_steps[1] for n in bucket]
        print(
            f"{netting.value:16s} {app_type.value:28s} | count={len(bucket):3d} | "
            f"q=[{min(qs)}, {max(qs)}], r=[{min(rs)}, {max(rs)}]"
        )

    print("\n=== Sample nodes (first 3 per netting/app) ===")
    for (netting, app_type), bucket in sorted(grouped.items(), key=lambda x: (x[0][0].value, x[0][1].value)):
        print(f"\n{netting.value} / {app_type.value}")
        for node in bucket[:3]:
            q, r = node.lattice_steps
            print(
                f"  id={node.id:6d} q={q:3d} r={r:3d} "
                f"vd={node.vector_direction.value:19s} pos=({node.position.real:.3f}, {node.position.imag:.3f})"
            )


def main() -> None:
    parser = argparse.ArgumentParser(description="Inspect InfiniteCoherentGraph lattice coordinates.")
    parser.add_argument(
        "--range",
        type=int,
        default=2,
        help="Inclusive lattice range for both q and r (e.g., 2 covers -2..+2).",
    )
    args = parser.parse_args()

    patch_range = range(-args.range, args.range + 1)
    graph = InfiniteCoherentGraph(stream_distance=100.0, scale=1.0)
    nodes = graph.get_patch(patch_range, patch_range)

    print(f"Generated {len(nodes)} nodes for q/r in {patch_range.start}..{patch_range.stop - 1}")
    summarize(nodes)


if __name__ == "__main__":
    main()
